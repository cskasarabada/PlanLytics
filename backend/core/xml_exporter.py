# core/xml_exporter.py
"""
Generate an Oracle ICM IcCnPlanCopy-compatible XML export from an oracle_mapping dict.

This produces XML that can be re-imported into Oracle Fusion ICM via the Plan Copy
import utility.  The XML follows the same structure as Oracle's native plan export:

    IcCnPlanCopy
      └─ PlanObjects
           └─ CompPlan (attrs: Name, OrgId, StartDate, EndDate, BusinessUnit)
                ├─ CompPlansVORow (plan details)
                ├─ PlanComponent (per component)
                │    ├─ PlanComponentsVORow
                │    ├─ Formula (MEASURE)
                │    │    ├─ Expression → ExpressionsVORow
                │    │    └─ GoalsVORow
                │    ├─ Formula (INCENTIVE_FORMULA)
                │    │    ├─ Expression → ExpressionsVORow
                │    │    └─ RateTable → RateDimension → tiers + values
                │    └─ EligibleCat (credit categories)
                └─ CompPlanComponentsVORow (plan→component links)
"""
import xml.etree.ElementTree as ET
from xml.dom import minidom
from datetime import datetime
from typing import Dict, Any, Optional
from collections import defaultdict


def generate_icm_xml(
    oracle_mapping: dict,
    org_id: int = 0,
    business_unit: str = "Business Unit",
    plan_year: Optional[int] = None,
) -> bytes:
    """Generate IcCnPlanCopy XML bytes from an oracle_mapping dict.

    Args:
        oracle_mapping: The oracle_mapping dict (same structure as LLM pipeline output)
        org_id: Oracle organization ID
        business_unit: Business unit name for the XML header
        plan_year: Plan fiscal year (used for dates; defaults to current year)

    Returns:
        bytes of the XML document (UTF-8 encoded)
    """
    if plan_year is None:
        plan_year = datetime.now().year

    start_date = f"{plan_year}-01-01"
    end_date = f"{plan_year}-12-31"

    plans = oracle_mapping.get("compensation_plans", [])
    components = oracle_mapping.get("plan_components", [])
    measures = oracle_mapping.get("performance_measures", [])
    expressions = oracle_mapping.get("expressions", [])
    rate_tables = oracle_mapping.get("rate_tables", [])
    rate_table_rates = oracle_mapping.get("rate_table_rates", [])
    rate_dims = oracle_mapping.get("rate_dimensions", [])
    credit_cats = oracle_mapping.get("credit_categories", [])
    goals = oracle_mapping.get("performance_goals", [])
    calc_settings = oracle_mapping.get("calculation_settings", [])

    # Index objects by name for lookups
    expr_by_name = _group_expressions(expressions)
    rt_by_name = {rt.get("rate_table_name", rt.get("table_name", "")): rt for rt in rate_tables}
    rtr_by_table = defaultdict(list)
    for rtr in rate_table_rates:
        rtr_by_table[rtr.get("rate_table_name", "")].append(rtr)
    dim_by_name = defaultdict(list)
    for rd in rate_dims:
        dim_by_name[rd.get("rate_dimension_name", "")].append(rd)
    measure_by_name = {m.get("name", ""): m for m in measures}
    goals_by_measure = defaultdict(list)
    for g in goals:
        goals_by_measure[g.get("performance_measure_name", "")].append(g)
    cs_by_component = {cs.get("plan_component_name", ""): cs for cs in calc_settings}

    # Map credit categories by name for fast lookup
    cc_names_set = {cc.get("credit_category_name", cc.get("name", "")) for cc in credit_cats}

    # ── Build XML tree ──
    root = ET.Element("IcCnPlanCopy")
    root.set("Date", datetime.now().strftime("%a %b %d %H:%M:%S UTC %Y"))
    root.set("ServerURI", "Generated by PlanLytics")
    root.set("User", "PlanLytics")

    plan_objects = ET.SubElement(root, "PlanObjects")

    # Use first plan (or synthesize one)
    plan = plans[0] if plans else {
        "name": "Compensation Plan",
        "start_date": start_date,
        "end_date": end_date,
    }
    plan_name = plan.get("name", "Compensation Plan")
    plan_start = plan.get("start_date", start_date)
    plan_end = plan.get("end_date", end_date)
    plan_org_id = plan.get("org_id", org_id)

    comp_plan = ET.SubElement(plan_objects, "CompPlan")
    comp_plan.set("BusinessUnit", business_unit)
    comp_plan.set("OrgId", str(plan_org_id))
    comp_plan.set("Name", plan_name)
    comp_plan.set("StartDate", plan_start)
    comp_plan.set("EndDate", plan_end)

    # CompPlansVORow
    cp_row = ET.SubElement(comp_plan, "CompPlansVORow")
    _add_text_child(cp_row, "CompPlanName", plan_name)
    _add_text_child(cp_row, "ApprovalStatus", "PENDING")
    _add_text_child(cp_row, "PlanStatus", "INCOMPLETE")
    _add_text_child(cp_row, "OrgId", str(plan_org_id))
    _add_text_child(cp_row, "StartDate", plan_start)
    _add_text_child(cp_row, "EndDate", plan_end)
    _add_text_child(cp_row, "TargetIncentive", str(plan.get("target_incentive", 0)))
    _add_text_child(cp_row, "AllowEcatOverlapFlag", "Y")
    _add_text_child(cp_row, "Description", plan.get("description", plan_name))
    _add_text_child(cp_row, "DisplayName", plan.get("display_name", plan_name))

    # ── Plan Components ──
    calc_seq = 0
    for pc in components:
        calc_seq += 1
        pc_name = pc.get("plan_component_name", "")
        pc_type = pc.get("incentive_type", "BONUS")
        pc_start = pc.get("start_date", plan_start)
        pc_end = pc.get("end_date", plan_end)

        pc_elem = ET.SubElement(comp_plan, "PlanComponent")
        pc_elem.set("Name", pc_name)
        pc_elem.set("StartDate", pc_start)
        pc_elem.set("EndDate", pc_end)
        pc_elem.set("IncentiveType", pc_type)

        # PlanComponentsVORow
        pc_row = ET.SubElement(pc_elem, "PlanComponentsVORow")
        _add_text_child(pc_row, "PlanComponentName", pc_name)
        _add_text_child(pc_row, "Description", pc_name)
        _add_text_child(pc_row, "IncentiveType", pc_type)
        _add_text_child(pc_row, "StartDate", pc_start)
        _add_text_child(pc_row, "EndDate", pc_end)
        _add_text_child(pc_row, "CalculationPhase", "1")
        _add_text_child(pc_row, "IndirectCredit",
                        pc.get("include_indirect_credits", "NONE").upper()
                        if pc.get("include_indirect_credits", "None") != "None" else "NONE")
        _add_text_child(pc_row, "DisplayName", pc_name)

        # ── MEASURE Formula ──
        pm_name = pc.get("performance_measure_name", pc_name)
        pm = measure_by_name.get(pm_name, {})
        if pm:
            measure_formula = ET.SubElement(pc_elem, "Formula")
            measure_formula.set("Name", pm_name)
            measure_formula.set("Type", "MEASURE")
            measure_formula.set("StartDate", pc_start)
            measure_formula.set("EndDate", pc_end)
            accum = _goal_interval_to_accum(pm.get("performance_interval", "Period"))
            measure_formula.set("ProcessTransaction",
                                "GROUP" if pm.get("process_transactions", "Yes") == "Yes" else "NONE")
            measure_formula.set("AccumulationInterval", accum)

            # Measure expression
            mfe_name = pm.get("measure_formula_expression_name", "")
            if mfe_name and mfe_name in expr_by_name:
                _add_expression_element(measure_formula, mfe_name, expr_by_name[mfe_name],
                                        plan_org_id, "MEASURE")

            # Goals
            pm_goals = goals_by_measure.get(pm_name, [])
            for g in pm_goals:
                goal_row = ET.SubElement(measure_formula, "GoalsVORow")
                _add_text_child(goal_row, "OrgId", str(plan_org_id))
                _add_text_child(goal_row, "GoalName", pm_name)
                _add_text_child(goal_row, "Description", pm_name)
                _add_text_child(goal_row, "StartDate", pc_start)
                _add_text_child(goal_row, "EndDate", pc_end)
                _add_text_child(goal_row, "UnitOfMeasure",
                                pm.get("unit_of_measure", "AMOUNT"))
                _add_text_child(goal_row, "Target", str(g.get("goal_target", 0)))

        # ── INCENTIVE_FORMULA Formula ──
        ife_name = pc.get("incentive_formula_expression", "")
        rt_name = pc.get("rate_table_name", "")
        if ife_name or rt_name:
            inc_formula = ET.SubElement(pc_elem, "Formula")
            inc_formula.set("Name", pc_name)
            inc_formula.set("Type", "INCENTIVE_FORMULA")
            inc_formula.set("StartDate", pc_start)
            inc_formula.set("EndDate", pc_end)
            inc_formula.set("ProcessTransaction", "NONE")
            inc_formula.set("AccumulationInterval", "Period")

            # Incentive formula expression
            if ife_name and ife_name in expr_by_name:
                _add_expression_element(inc_formula, ife_name, expr_by_name[ife_name],
                                        plan_org_id, "INCENTIVE_FORMULA")

            # Rate table
            if rt_name and rt_name in rt_by_name:
                rt = rt_by_name[rt_name]
                rt_elem = ET.SubElement(inc_formula, "RateTable")
                rt_elem.set("Name", rt_name)
                rt_elem.set("Type", rt.get("rate_table_type", "AMOUNT"))

                # Rate dimensions
                for dim_name, dim_tiers in dim_by_name.items():
                    # Check if this dimension's tiers match the rate table's rates
                    dim_elem = ET.SubElement(rt_elem, "RateDimension")
                    dim_elem.set("Name", dim_name)
                    dim_elem.set("Type", dim_tiers[0].get("rate_dimension_type", "AMOUNT") if dim_tiers else "AMOUNT")
                    for tier in sorted(dim_tiers, key=lambda t: t.get("tier_sequence", 0)):
                        tier_row = ET.SubElement(dim_elem, "RateDimTierVORow")
                        _add_text_child(tier_row, "TierSequence", str(tier.get("tier_sequence", 1)))
                        _add_text_child(tier_row, "MinimumAmount", str(tier.get("minimum_amount", 0)))
                        _add_text_child(tier_row, "MaximumAmount", str(tier.get("maximum_amount", 999999)))

                # Rate table values
                for rv in sorted(rtr_by_table.get(rt_name, []),
                                 key=lambda r: r.get("tier_sequence", 0)):
                    rv_row = ET.SubElement(rt_elem, "RateTableValueVORow")
                    _add_text_child(rv_row, "RateSequence", str(rv.get("tier_sequence", 1)))
                    _add_text_child(rv_row, "CommissionValue", str(rv.get("rate_value", 0)))
                    _add_text_child(rv_row, "MinimumAmount", str(rv.get("minimum_amount", 0)))
                    _add_text_child(rv_row, "MaximumAmount", str(rv.get("maximum_amount", 999999)))

            # Rate dimension input expression
            rdi_name = pc.get("rate_dimension_input_expression")
            if rdi_name:
                fi_row = ET.SubElement(inc_formula, "FormulaInputExpsVORow")
                _add_text_child(fi_row, "ExpressionName", rdi_name)
                _add_text_child(fi_row, "SplitFlag", "N")

        # ── Eligible Categories ──
        # Find credit categories linked to this component's measure
        pm_cc = pm.get("credit_category_name", "") if pm else ""
        if pm_cc:
            ecat = ET.SubElement(pc_elem, "EligibleCat")
            ecat.set("Name", pm_cc)
            ecat_row = ET.SubElement(ecat, "EligibleCatsVORow")
            _add_text_child(ecat_row, "OrgId", str(plan_org_id))
            _add_text_child(ecat_row, "CreditCategoryName", pm_cc)

        # ── FormulasVORow (calculation settings) ──
        cs = cs_by_component.get(pc_name, {})
        if cs:
            f_row = ET.SubElement(pc_elem, "FormulasVORow")
            split_map = {"No": "NONE", "Yes": "SPLIT"}
            split_val = split_map.get(cs.get("split_attainment", "No"), "NONE")
            _add_text_child(f_row, "SplitOption", split_val)
            _add_text_child(f_row, "ProcessTxn",
                            "GROUP" if cs.get("process_transactions", "").startswith("Group") else "NONE")

        # CompPlanComponentsVORow (plan→component link)
        cpc_row = ET.SubElement(comp_plan, "CompPlanComponentsVORow")
        _add_text_child(cpc_row, "OrgId", str(plan_org_id))
        _add_text_child(cpc_row, "PlanComponentName", pc_name)
        _add_text_child(cpc_row, "CalculationSequence", str(calc_seq))
        _add_text_child(cpc_row, "TargetIncentiveWeight", "0")
        _add_text_child(cpc_row, "CalculationPhase", "1")
        _add_text_child(cpc_row, "IndirectCredit",
                        pc.get("include_indirect_credits", "NONE").upper()
                        if pc.get("include_indirect_credits", "None") != "None" else "NONE")

    # ── Pretty-print and return bytes ──
    rough = ET.tostring(root, encoding="unicode", xml_declaration=False)
    rough = '<?xml version = \'1.0\' encoding = \'UTF-8\'?>\n' + rough
    try:
        dom = minidom.parseString(rough)
        pretty = dom.toprettyxml(indent="   ", encoding="UTF-8")
        # Remove the extra xml declaration that minidom adds
        lines = pretty.decode("UTF-8").split("\n")
        if lines[0].startswith("<?xml"):
            lines[0] = "<?xml version = '1.0' encoding = 'UTF-8'?>"
        return "\n".join(lines).encode("UTF-8")
    except Exception:
        return rough.encode("UTF-8")


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _add_text_child(parent: ET.Element, tag: str, text: str):
    """Add a child element with text content."""
    child = ET.SubElement(parent, tag)
    child.text = str(text) if text is not None else ""


def _group_expressions(expressions: list) -> Dict[str, list]:
    """Group expression detail rows by expression_name."""
    by_name: Dict[str, list] = defaultdict(list)
    for e in expressions:
        by_name[e.get("expression_name", "")].append(e)
    return dict(by_name)


def _goal_interval_to_accum(interval: str) -> str:
    """Convert GoalInterval back to XML AccumulationInterval."""
    mapping = {
        "Period": "Period",
        "Quarterly": "Quarter",
        "Yearly": "Year",
        "Cumulative": "Cumulative",
    }
    return mapping.get(interval, "Period")


def _render_expression(detail_rows: list) -> str:
    """Reconstruct the rendered expression text from detail rows."""
    parts = []
    for row in sorted(detail_rows, key=lambda r: r.get("sequence", 0)):
        dt = row.get("expression_detail_type", "")
        if dt == "Primary object attribute":
            group = row.get("basic_attributes_group", "Credit")
            attr = row.get("basic_attribute_name", "Credit Amount")
            parts.append(f"SUM ( {group}.{attr} )")
        elif dt == "Measure result":
            mn = row.get("measure_name", "")
            ma = row.get("measure_result_attribute", "PTD Output Achieved")
            parts.append(f"Measure result.{mn}.{ma}")
        elif dt == "Plan component result":
            pn = row.get("plan_component_name", "")
            pa = row.get("plan_component_result_attribute", "PTD Output Achieved")
            parts.append(f"Plan component result.{pn}.{pa}")
        elif dt == "Math operator":
            parts.append(row.get("expression_operator", "+"))
        elif dt == "Constant":
            parts.append(str(row.get("constant_value", "0")))
        elif dt:
            parts.append(row.get("description", dt))
    return " ".join(parts)


def _infer_expression_usage_code(category: str, formula_type: str) -> str:
    """Map expression category + formula type to Oracle UsageCode."""
    if formula_type == "MEASURE":
        if category == "Attainment":
            return "MEASURE_GROUP_INPUT"
        return "MEASURE_GROUP_INPUT"
    # INCENTIVE_FORMULA
    if category == "Earnings":
        return "INCENTIVE_FORM_BONUS_INPUT"
    return "INCENTIVE_FORM_COMM_INPUT"


def _add_expression_element(
    parent: ET.Element,
    expr_name: str,
    detail_rows: list,
    org_id: int,
    formula_type: str,
):
    """Add an Expression element with its details to the parent Formula."""
    category = detail_rows[0].get("expression_category", "Earnings") if detail_rows else "Earnings"

    expr_elem = ET.SubElement(parent, "Expression")
    expr_elem.set("Name", expr_name)
    expr_elem.set("Type", "CALCULATION")

    expr_vo = ET.SubElement(expr_elem, "ExpressionsVORow")
    _add_text_child(expr_vo, "ExpressionName", expr_name)
    _add_text_child(expr_vo, "Description", expr_name)
    _add_text_child(expr_vo, "ExpressionType", "CALCULATION")
    _add_text_child(expr_vo, "StatusCode", "VALID")
    _add_text_child(expr_vo, "UsesRatetblRsltFlag", "N")
    _add_text_child(expr_vo, "EnabledFlag", "Y")

    # Rendered expression
    rendered = _render_expression(detail_rows)
    _add_text_child(expr_vo, "RenderedExpressionDisp", rendered)

    # Expression details (structural detail rows)
    details_parent = ET.SubElement(expr_vo, "ExpressionDetails")
    seq = 0
    for row in sorted(detail_rows, key=lambda r: r.get("sequence", 0)):
        dt = row.get("expression_detail_type", "")
        seq += 1

        if dt == "Primary object attribute":
            # SUM function
            _add_expr_detail_row(details_parent, org_id, seq, "SUM", "FUNCTION", "SUM")
            seq += 1
            _add_expr_detail_row(details_parent, org_id, seq, "(", "OPERATOR")
            seq += 1
            group = row.get("basic_attributes_group", "Credit")
            attr = row.get("basic_attribute_name", "Credit Amount")
            detail = ET.SubElement(details_parent, "ExpressionDetail")
            detail.set("TableName", "CN_TP_CREDITS_ALL")
            detail.set("ColumnName", "CREDIT_AMT_CALC_CURR")
            d_row = ET.SubElement(detail, "ExpressionDetailsVORow")
            _add_text_child(d_row, "OrgId", str(org_id))
            _add_text_child(d_row, "ItemSequence", str(seq))
            _add_text_child(d_row, "ItemDisplayValue", f"{group}.{attr}")
            _add_text_child(d_row, "ItemSourceType", "TRANSACTION_CREDIT")
            seq += 1
            _add_expr_detail_row(details_parent, org_id, seq, ")", "OPERATOR")

        elif dt == "Measure result":
            mn = row.get("measure_name", "")
            ma = row.get("measure_result_attribute", "PTD Output Achieved")
            _add_expr_detail_row(details_parent, org_id, seq,
                                 f"Measure result.{mn}.{ma}", "FORMULA_RESULT")

        elif dt == "Plan component result":
            pn = row.get("plan_component_name", "")
            pa = row.get("plan_component_result_attribute", "PTD Output Achieved")
            _add_expr_detail_row(details_parent, org_id, seq,
                                 f"Plan component result.{pn}.{pa}", "COMP_RESULT")

        elif dt == "Math operator":
            op = row.get("expression_operator", "+")
            _add_expr_detail_row(details_parent, org_id, seq, op, "OPERATOR")

        elif dt == "Constant":
            val = str(row.get("constant_value", "0"))
            _add_expr_detail_row(details_parent, org_id, seq, val, "CONSTANT")

    # Expression usages
    usages_parent = ET.SubElement(expr_vo, "ExpressionUsages")
    usage_code = _infer_expression_usage_code(category, formula_type)
    usage_row = ET.SubElement(usages_parent, "ExpressionUsagesVORow")
    _add_text_child(usage_row, "OrgId", str(org_id))
    _add_text_child(usage_row, "UsageCode", usage_code)
    _add_text_child(usage_row, "Description", expr_name)
    _add_text_child(usage_row, "EnabledFlag", "Y")
    _add_text_child(usage_row, "ExpressionName", expr_name)
    _add_text_child(usage_row, "ExpressionType", "CALCULATION")
    _add_text_child(usage_row, "StatusCode", "VALID")


def _add_expr_detail_row(
    parent: ET.Element,
    org_id: int,
    seq: int,
    display_value: str,
    source_type: str,
    source_code: str = "",
):
    """Add an ExpressionDetailsVORow element."""
    row = ET.SubElement(parent, "ExpressionDetailsVORow")
    _add_text_child(row, "OrgId", str(org_id))
    _add_text_child(row, "ItemSequence", str(seq))
    _add_text_child(row, "ItemDisplayValue", display_value)
    _add_text_child(row, "ItemSourceType", source_type)
    if source_code:
        _add_text_child(row, "ItemSourceCode", source_code)
